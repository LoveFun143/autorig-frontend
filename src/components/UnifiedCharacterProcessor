// src/components/UnifiedCharacterProcessor.js
import * as bodyPix from '@tensorflow-models/body-pix';

class UnifiedCharacterProcessor {
  constructor() {
    this.bodyPixModel = null;
    this.canvas = document.createElement('canvas');
    this.ctx = this.canvas.getContext('2d');
  }

  async initialize() {
    console.log('ðŸš€ Loading AI models for character processing...');
    
    try {
      this.bodyPixModel = await bodyPix.load({
        architecture: 'MobileNetV1',
        outputStride: 16,
        multiplier: 0.75,
        quantBytes: 2
      });
      console.log('âœ… AI models loaded successfully!');
    } catch (error) {
      console.error('Failed to load AI model:', error);
      // Fallback to basic processing if AI fails
      this.bodyPixModel = null;
    }
  }

  async processCharacter(imageUrl) {
    const img = await this.loadImage(imageUrl);
    this.canvas.width = img.width;
    this.canvas.height = img.height;
    
    console.log('ðŸŽ¯ Processing character image...');
    
    // Check if image has transparency (PNG with alpha channel)
    const hasTransparency = await this.checkTransparency(img);
    console.log(`ðŸ“Š Image has transparency: ${hasTransparency}`);
    
    // Detect all character instances in the image
    const characterRegions = await this.detectCharacterRegions(img, hasTransparency);
    console.log(`ðŸ‘¥ Found ${characterRegions.length} character region(s)`);
    
    // If multiple characters/poses found, merge them intelligently
    let primaryCharacter;
    if (characterRegions.length > 1) {
      primaryCharacter = await this.mergeCharacterPoses(characterRegions, img);
      console.log('ðŸ”„ Merged multiple poses into single character');
    } else if (characterRegions.length === 1) {
      primaryCharacter = characterRegions[0];
    } else {
      // No clear character found, use whole image
      primaryCharacter = {
        bounds: { x: 0, y: 0, width: img.width, height: img.height },
        mask: new Uint8ClampedArray(img.width * img.height).fill(255)
      };
    }
    
    // Create properly segmented layers
    const layers = await this.createCharacterLayers(img, primaryCharacter, hasTransparency);
    
    return {
      layers,
      skeleton: this.createSkeleton(primaryCharacter.bounds),
      animations: this.createAnimations(),
      metadata: {
        hasTransparency,
        characterCount: characterRegions.length,
        merged: characterRegions.length > 1
      }
    };
  }

  async checkTransparency(img) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.drawImage(img, 0, 0);
    const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    // Check for any transparent pixels
    for (let i = 3; i < data.length; i += 4) {
      if (data[i] < 255) {
        return true;
      }
    }
    return false;
  }

  async detectCharacterRegions(img, hasTransparency) {
    const regions = [];
    
    if (hasTransparency) {
      // For transparent images, use alpha channel to detect character
      const mask = await this.createMaskFromAlpha(img);
      const bounds = this.findBoundsFromMask(mask, img.width, img.height);
      
      regions.push({
        bounds,
        mask,
        confidence: 1.0
      });
    } else if (this.bodyPixModel) {
      // Use AI for non-transparent images
      try {
        const segmentation = await this.bodyPixModel.segmentPerson(img, {
          flipHorizontal: false,
          internalResolution: 'medium',
          segmentationThreshold: 0.5
        });
        
        // Convert segmentation to mask
        const mask = new Uint8ClampedArray(segmentation.data.length);
        for (let i = 0; i < segmentation.data.length; i++) {
          mask[i] = segmentation.data[i] === 1 ? 255 : 0;
        }
        
        const bounds = this.findBoundsFromMask(mask, img.width, img.height);
        regions.push({
          bounds,
          mask,
          confidence: 0.9
        });
      } catch (error) {
        console.error('AI segmentation failed:', error);
      }
    }
    
    // Fallback: detect by color difference from background
    if (regions.length === 0) {
      const mask = await this.createMaskFromColorDifference(img);
      const bounds = this.findBoundsFromMask(mask, img.width, img.height);
      regions.push({
        bounds,
        mask,
        confidence: 0.7
      });
    }
    
    return regions;
  }

  async createMaskFromAlpha(img) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.drawImage(img, 0, 0);
    const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    const mask = new Uint8ClampedArray(img.width * img.height);
    
    for (let i = 0; i < mask.length; i++) {
      // Use alpha channel directly
      mask[i] = data[i * 4 + 3];
    }
    
    return mask;
  }

  async createMaskFromColorDifference(img) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCtx.drawImage(img, 0, 0);
    const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    // Sample background colors from corners
    const bgColors = this.sampleBackgroundColors(data, img.width, img.height);
    
    const mask = new Uint8ClampedArray(img.width * img.height);
    
    for (let i = 0; i < mask.length; i++) {
      const idx = i * 4;
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      
      let isBackground = false;
      for (const bg of bgColors) {
        const diff = Math.abs(r - bg.r) + Math.abs(g - bg.g) + Math.abs(b - bg.b);
        if (diff < 30) {
          isBackground = true;
          break;
        }
      }
      
      mask[i] = isBackground ? 0 : 255;
    }
    
    // Clean up the mask
    this.cleanupMask(mask, img.width, img.height);
    
    return mask;
  }

  sampleBackgroundColors(data, width, height) {
    const colors = [];
    const samplePoints = [
      { x: 0, y: 0 },
      { x: width - 1, y: 0 },
      { x: 0, y: height - 1 },
      { x: width - 1, y: height - 1 }
    ];
    
    for (const point of samplePoints) {
      const idx = (point.y * width + point.x) * 4;
      colors.push({
        r: data[idx],
        g: data[idx + 1],
        b: data[idx + 2]
      });
    }
    
    return colors;
  }

  cleanupMask(mask, width, height) {
    // Simple erosion to remove noise
    const temp = new Uint8ClampedArray(mask);
    
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        const idx = y * width + x;
        
        if (mask[idx] === 255) {
          let neighbors = 0;
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (mask[(y + dy) * width + (x + dx)] === 255) {
                neighbors++;
              }
            }
          }
          
          if (neighbors < 5) {
            temp[idx] = 0;
          }
        }
      }
    }
    
    for (let i = 0; i < mask.length; i++) {
      mask[i] = temp[i];
    }
  }

  findBoundsFromMask(mask, width, height) {
    let minX = width, maxX = 0, minY = height, maxY = 0;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (mask[y * width + x] > 0) {
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
      }
    }
    
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  async mergeCharacterPoses(regions, img) {
    // Find the largest/most confident region as primary
    let primary = regions.reduce((best, current) => {
      const currentArea = current.bounds.width * current.bounds.height;
      const bestArea = best.bounds.width * best.bounds.height;
      return (currentArea * current.confidence > bestArea * best.confidence) ? current : best;
    });
    
    // Merge masks from all regions
    const mergedMask = new Uint8ClampedArray(primary.mask);
    for (const region of regions) {
      if (region !== primary) {
        for (let i = 0; i < mergedMask.length; i++) {
          mergedMask[i] = Math.max(mergedMask[i], region.mask[i]);
        }
      }
    }
    
    return {
      bounds: this.findBoundsFromMask(mergedMask, img.width, img.height),
      mask: mergedMask
    };
  }

  async createCharacterLayers(img, character, hasTransparency) {
    const layers = [];
    
    // Create base character layer (full character with transparency)
    const baseLayer = await this.createBaseLayer(img, character.mask);
    layers.push(baseLayer);
    
    // Estimate body part regions
    const partRegions = this.estimateBodyParts(character.bounds);
    
    // Create individual part layers
    for (const [partName, region] of Object.entries(partRegions)) {
      const partLayer = await this.createPartLayer(img, partName, region, character.mask);
      if (partLayer.hasContent) {
        layers.push(partLayer);
      }
    }
    
    // Sort layers by z-index
    layers.sort((a, b) => a.zIndex - b.zIndex);
    
    return layers;
  }

  async createBaseLayer(img, mask) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0);
    
    // Apply mask to remove background
    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    for (let i = 0; i < mask.length; i++) {
      if (mask[i] === 0) {
        data[i * 4 + 3] = 0; // Make transparent
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return {
      id: 'base_character',
      type: 'base',
      imageData: canvas.toDataURL('image/png'),
      zIndex: 0,
      hasContent: true
    };
  }

  async createPartLayer(img, partName, region, characterMask) {
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, img.width, img.height);
    
    // Draw only the part region
    ctx.drawImage(
      img,
      region.x, region.y, region.width, region.height,
      region.x, region.y, region.width, region.height
    );
    
    // Apply character mask to ensure we don't include background
    const imageData = ctx.getImageData(0, 0, img.width, img.height);
    const data = imageData.data;
    
    let hasContent = false;
    for (let y = 0; y < img.height; y++) {
      for (let x = 0; x < img.width; x++) {
        const idx = y * img.width + x;
        const pixelIdx = idx * 4;
        
        // Check if pixel is outside character or part region
        if (characterMask[idx] === 0 || 
            x < region.x || x > region.x + region.width ||
            y < region.y || y > region.y + region.height) {
          data[pixelIdx + 3] = 0; // Make transparent
        } else if (data[pixelIdx + 3] > 0) {
          hasContent = true;
        }
      }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    return {
      id: `${partName}_layer`,
      type: partName,
      imageData: canvas.toDataURL('image/png'),
      zIndex: this.getZIndex(partName),
      hasContent,
      bounds: region
    };
  }

  estimateBodyParts(bounds) {
    // Estimate body part positions based on typical proportions
    const w = bounds.width;
    const h = bounds.height;
    const x = bounds.x;
    const y = bounds.y;
    
    return {
      head: {
        x: x + w * 0.2,
        y: y,
        width: w * 0.6,
        height: h * 0.25
      },
      eyes: {
        x: x + w * 0.25,
        y: y + h * 0.08,
        width: w * 0.5,
        height: h * 0.06
      },
      mouth: {
        x: x + w * 0.3,
        y: y + h * 0.15,
        width: w * 0.4,
        height: h * 0.05
      },
      torso: {
        x: x + w * 0.15,
        y: y + h * 0.25,
        width: w * 0.7,
        height: h * 0.4
      },
      left_arm: {
        x: x,
        y: y + h * 0.25,
        width: w * 0.3,
        height: h * 0.4
      },
      right_arm: {
        x: x + w * 0.7,
        y: y + h * 0.25,
        width: w * 0.3,
        height: h * 0.4
      },
      legs: {
        x: x + w * 0.2,
        y: y + h * 0.6,
        width: w * 0.6,
        height: h * 0.4
      }
    };
  }

  getZIndex(partName) {
    const zIndexMap = {
      'base': 0,
      'legs': 1,
      'torso': 2,
      'left_arm': 3,
      'right_arm': 3,
      'head': 4,
      'eyes': 5,
      'mouth': 5
    };
    return zIndexMap[partName] || 0;
  }

  createSkeleton(bounds) {
    const cx = bounds.x + bounds.width / 2;
    const cy = bounds.y + bounds.height / 2;
    
    return {
      joints: [
        { name: 'head', x: cx, y: bounds.y + bounds.height * 0.1 },
        { name: 'neck', x: cx, y: bounds.y + bounds.height * 0.2 },
        { name: 'chest', x: cx, y: bounds.y + bounds.height * 0.35 },
        { name: 'pelvis', x: cx, y: bounds.y + bounds.height * 0.6 },
        { name: 'left_shoulder', x: cx - bounds.width * 0.2, y: bounds.y + bounds.height * 0.25 },
        { name: 'right_shoulder', x: cx + bounds.width * 0.2, y: bounds.y + bounds.height * 0.25 },
        { name: 'left_elbow', x: cx - bounds.width * 0.25, y: bounds.y + bounds.height * 0.4 },
        { name: 'right_elbow', x: cx + bounds.width * 0.25, y: bounds.y + bounds.height * 0.4 },
        { name: 'left_hand', x: cx - bounds.width * 0.3, y: bounds.y + bounds.height * 0.55 },
        { name: 'right_hand', x: cx + bounds.width * 0.3, y: bounds.y + bounds.height * 0.55 }
      ],
      bones: [
        ['head', 'neck'],
        ['neck', 'chest'],
        ['chest', 'pelvis'],
        ['chest', 'left_shoulder'],
        ['chest', 'right_shoulder'],
        ['left_shoulder', 'left_elbow'],
        ['right_shoulder', 'right_elbow'],
        ['left_elbow', 'left_hand'],
        ['right_elbow', 'right_hand']
      ]
    };
  }

  createAnimations() {
    return {
      blink: {
        layers: ['eyes'],
        keyframes: [
          { time: 0, scaleY: 1 },
          { time: 0.1, scaleY: 0.1 },
          { time: 0.2, scaleY: 1 }
        ],
        duration: 200
      },
      smile: {
        layers: ['mouth'],
        keyframes: [
          { time: 0, scaleX: 1, scaleY: 1 },
          { time: 0.5, scaleX: 1.2, scaleY: 0.9 },
          { time: 1, scaleX: 1, scaleY: 1 }
        ],
        duration: 600
      },
      wave: {
        layers: ['right_arm'],
        keyframes: [
          { time: 0, rotate: 0 },
          { time: 0.25, rotate: -30 },
          { time: 0.75, rotate: 30 },
          { time: 1, rotate: 0 }
        ],
        duration: 1000
      },
      headTurn: {
        layers: ['head', 'eyes', 'mouth'],
        keyframes: [
          { time: 0, rotate: 0 },
          { time: 0.5, rotate: 8 },
          { time: 1, rotate: 0 }
        ],
        duration: 1200
      },
      idle: {
        layers: ['torso', 'base'],
        keyframes: [
          { time: 0, translateY: 0 },
          { time: 0.5, translateY: -2 },
          { time: 1, translateY: 0 }
        ],
        duration: 3000
      }
    };
  }

  async loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }
}

export default UnifiedCharacterProcessor;
